// Gora DAO proposal Smart Contract
// Version 1
// Website: https://www.gora.io/
// Creators: @emg110.algo
// Github: https://github.com/GoraNetwork/gora-dao-smartcontracts
/////////////////////////////////////////////////////////////////

#pragma version 8

//Check TXN first
callsub sub_check_txn

// Check creation TXN
// txn ApplicationID
// bz branch_create

// Checking onCompletion type for update application call
//txn OnCompletion
//int UpdateApplication
//==
//txn ApplicationID
//int 0
//!=
//&&
//bnz branch_update

// Checking onCompletion type for delete application call
txn OnCompletion
int DeleteApplication
==
txn ApplicationID
int 0
!=
&&
bnz branch_delete

// Checking onCompletion type for close out application call
txn OnCompletion
int CloseOut
==
txn ApplicationID
int 0
!=
&&
bnz branch_closeout

// Checking onCompletion type for optin application call
txn OnCompletion
int OptIn
==
bnz branch_error

// Checks the number of application args , if 0 then no method it is
txn NumAppArgs
int 0
==
bz branch_method_router
b branch_error

///////////////////////////////////////////


branch_delete:

	callsub sub_check_owner_auth

	int 1
	return




branch_closeout:

	callsub sub_check_owner_auth

	int 1
	return

///////////////////////////////////////////
branch_method_router:

	method "create_proposal(application,uint64,uint64,address,address,string,string)address"
	txn ApplicationArgs 0
	==
	txn ApplicationID
	int 0
	==
	&&
	bnz method_create_proposal

	method "update_proposal(application,uint64,uint64,address,address,string,string)address"
	txn ApplicationArgs 0
	==
	bnz method_update_proposal

	method "optin_proposal_asset(asset,uint64)uint64"
	txn ApplicationArgs 0
	==
	bnz method_optin_proposal_asset

	method "config_proposal(pay,asset,uint64,account,account,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,(uint64,uint64,uint64,uint64,uint64,uint64))uint64"
	txn ApplicationArgs 0
	==
	bnz method_config_proposal

	method "update_manager_address(pay,byte[],byte[])string"
	txn ApplicationArgs 0
	==
	bnz method_update_manager_address

	method "activate_proposal(application,byte[],byte[])string"
	txn ApplicationArgs 0
	==
	bnz method_activate_proposal

	    method "proposal_participate(pay,asset,account,application)uint64"
	txn ApplicationArgs 0
	==
	bnz method_proposal_participate

    method "proposal_withdraw_participate(asset,account,application)uint64"
	txn ApplicationArgs 0
	==
	bnz method_proposal_withdraw_participate
	b branch_error

sub_check_txn:

	// Checks RekeyTo address transaction field to be empty (ZeroAddress)
	txn RekeyTo
	global ZeroAddress
	==
	assert

	// Checks CloseRemainderTo address transaction field to be empty (ZeroAddress)
	txn CloseRemainderTo
	global ZeroAddress
	==
	assert

	// Checks AssetCloseTo address transaction field to be empty (ZeroAddress)
	txn AssetCloseTo
	global ZeroAddress
	==
	assert

	// Check transaction type to be application call
	txn TypeEnum
	int appl
	==
	assert

	// Checking transaction fee
	txn Fee
	global MinTxnFee
	>=
	assert
	retsub

// Checks owner address authentication
sub_check_owner_auth:

	txn Sender
	global CreatorAddress
	==
	assert
	retsub

// Checks manager address authentication
sub_check_manager_auth:
	txn Sender
	byte "gora_dao_manager_address"
	app_global_get
	==
	assert
	retsub


method_create_proposal:

	global CurrentApplicationID
	store 0

	txn ApplicationArgs 1
	btoi
	store 1
	byte "gora_dao_app_id"
	load 1
	app_global_put


	txn ApplicationArgs 2
	btoi
	store 2
	byte "gora_dao_asset_id"
	load 2
	app_global_put

	txn ApplicationArgs 3
	btoi
	store 3
	byte "gora_dao_proposal_asset_id"
	load 3
	app_global_put

	txn ApplicationArgs 4
	store 4
	byte "gora_dao_proposal_creator_address"
	load 4
	app_global_put

	txn ApplicationArgs 5
	store 5
	byte "gora_dao_manager_address"
	load 5
	app_global_put

	txn ApplicationArgs 6
	store 6
	byte "gora_dao_proposal_title"
	load 6
	app_global_put

	txn ApplicationArgs 7
	store 7
	byte "gora_dao_proposal_description"
	load 7
	app_global_put


	byte "participation_count"
	int 0
	app_global_put

	byte "vote_count"
	int 0
	app_global_put

	byte "gora_dao_proposal_is_activated"
	int 0
	app_global_put


	byte 0x151f7c75
	global CurrentApplicationAddress
	concat
	b branch_log_return

method_update_proposal:
	byte "gora_dao_proposal_is_activated"
	app_global_get
	int 1
	!=
	assert

	global CurrentApplicationID
	store 0

	txn ApplicationArgs 1
	btoi
	store 1
	byte "gora_dao_app_id"
	load 1
	app_global_put

	txn ApplicationArgs 2
	btoi
	store 2
	byte "gora_dao_asset_id"
	load 2
	app_global_put

	txn ApplicationArgs 3
	btoi
	store 3
	byte "gora_dao_proposal_asset_id"
	load 3
	app_global_put

	txn ApplicationArgs 4
	store 4
	byte "gora_dao_proposal_creator_address"
	load 4
	app_global_put

	txn ApplicationArgs 5
	store 5
	byte "gora_dao_manager_address"
	load 5
	app_global_put

	txn ApplicationArgs 6
	store 6
	byte "gora_dao_proposal_title"
	load 6
	app_global_put

	txn ApplicationArgs 7
	store 7
	byte "gora_dao_proposal_description"
	load 7
	app_global_put

	byte "participation_count"
	int 0
	app_global_put

	byte "vote_count"
	int 0
	app_global_put


	byte 0x151f7c75
	global CurrentApplicationAddress
	concat
	b branch_log_return

method_optin_proposal_asset:
	callsub sub_check_owner_auth
	txna Assets 0
	store 0

	itxn_begin
	global CurrentApplicationAddress
	itxn_field Sender
	int axfer
	itxn_field TypeEnum
	global CurrentApplicationAddress
	itxn_field AssetReceiver
	int 0
	itxn_field AssetAmount
	txna Assets 0
	itxn_field XferAsset
	itxn_submit
	itxn TxID
    log
	
	itxn_begin
	global CurrentApplicationAddress
	itxn_field Sender
	int axfer
	itxn_field TypeEnum
	global CurrentApplicationAddress
	itxn_field AssetReceiver
	int 0
	itxn_field AssetAmount
	txna Assets 1
	itxn_field XferAsset
	itxn_submit
	itxn TxID
    log

	byte 0x151f7c75
	load 0
	itob
	concat
	b branch_log_return


method_update_manager_address:
	callsub sub_check_manager_auth

	txn ApplicationArgs 1
	byte "gora_dao_manager_address"
	app_global_put

	byte 0x151f7c75
	byte "Proposal manager address is now updated!"
	concat
	b branch_log_return

method_activate_proposal:
	callsub sub_check_manager_auth
	// Requiring that agreement on proposal activation is true
	byte "gora_dao_proposal_activation_allowed"
	app_global_get
	int 1
	==
	assert

	byte 0x151f7c75
	byte "Proposal is activated!"
	concat
	b branch_log_return

// Handles configuration of Proposal
method_config_proposal:
	txn ApplicationArgs 1
	store 1
	load 1
	//log

	txn ApplicationArgs 2
	store 2
	load 2
	//log

	txn ApplicationArgs 3
	store 3
	load 3
	//log

	txn ApplicationArgs 4
	store 4
	load 4
	//log

	txn ApplicationArgs 5
	store 5
	load 5
	//log

	txn ApplicationArgs 6
	store 6
	load 6
	//log

	txn ApplicationArgs 7
	store 7
	load 7
	//log

	txn ApplicationArgs 8
	store 8
	load 8
	//log

	txn ApplicationArgs 9
	store 9
	load 9
	//log

	txn ApplicationArgs 10
	store 10
	load 10
	//log

	txn ApplicationArgs 11
	store 11
	load 11
	//log

	// proposal_min_participation_fee
	txn ApplicationArgs 12
	store 12
	load 12
	//log


	txn ApplicationArgs 13
	store 20
	load 20
	//log

	
	byte "proposal_min_participation_algo"
	load 5
	btoi
	app_global_put

	
	byte "proposal_min_participation"
	load 6
	btoi
	app_global_put

	byte "proposal_min_participation_fee"
	load 12
	btoi
	app_global_put
	
	byte "proposal_duration"
	load 7
	btoi
	app_global_put

	byte "proposal_amount"
	load 8
	btoi
	app_global_put

	
	byte "proposal_vote_duration"
	load 10
	btoi
	app_global_put

	byte "proposal_vote_start"
	load 11
	btoi
	app_global_put

	load 20
	len
	int 8
	/
	store 13
	int 0
	store 14
	callsub extract_all_uint64_from_tuple
	
	
	byte "proposal_threshold"
	box_get
	bnz branch_delete_box
	byte "proposal_threshold"
	load 20
	box_put
	b extract_all_uint64_from_tuple

branch_delete_box:
		pop
		byte "proposal_threshold"
		box_del
		pop
	 	byte "proposal_threshold"
		load 20
		box_put

	 	b extract_all_uint64_from_tuple

extract_one_uint64_from_tuple:
	
	load 20
	load 14
	extract_uint64
	itob
	log
	load 14
	int 8
	+
	store 14
	
extract_all_uint64_from_tuple:
	load 13
	int 1
	-
	store 13
	load 13

	bnz extract_one_uint64_from_tuple

	load 20
	load 14
	extract_uint64
	itob
	log
	
	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return


method_proposal_participate:
	txna Accounts 0
	store 0
    // Checking Transaction group
    global GroupSize
    int 5
    ==
    assert

    // Checking the pay and axfer txns at index 0 and 1 of gtxn
    gtxn 3 RekeyTo
    global ZeroAddress
    ==
    assert

    gtxn 3 RekeyTo
    global ZeroAddress
    ==
    assert

    gtxn 3 CloseRemainderTo
    global ZeroAddress
    ==
    assert

    gtxn 3 CloseRemainderTo
    global ZeroAddress
    ==
    assert

    gtxn 3 AssetCloseTo
    global ZeroAddress
    ==
    assert

    gtxn 3 AssetCloseTo
    global ZeroAddress
    ==
    assert


    gtxn 3 TypeEnum
    int pay
    ==
    assert
   

    gtxn 3 Fee
    global MinTxnFee
    >=
    assert

    gtxn 3 Amount
    byte "proposal_min_participation_fee"
    app_global_get
    >=
    assert
	

    gtxn 3 Receiver
    global CurrentApplicationAddress
    ==
    assert
	

    // Checking account ref to be Sender
    load 0
    txn Sender
    ==
    assert



    // Checking the asset ref to be DAO asset
    byte "gora_dao_asset_id"
    app_global_get
    txna Assets 0
    ==
    assert


    load 0
    txna Assets 0
    asset_holding_get AssetBalance
    assert
	
	load 0
	box_get
	bnz branch_delete_participate_box
	load 0
    byte ""
    box_put
	
    byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return

branch_delete_participate_box:
	load 0
	box_del
	load 0
    byte "VOTE_PLACE_HOLDER"
    box_put

	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return


method_proposal_withdraw_participate:
 	txna Accounts 0
    store 0

	load 0
    box_del
    pop

	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return

branch_error:
	err

// Handles logging the last element on the stack then put a 1 on the top and return (log and approve)
branch_log_return:

	log

	int 1
	return

