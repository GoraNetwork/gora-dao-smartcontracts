// Gora DAO Staking Smart Contract
// Version 1
// Website: https://www.gora.io/
// Creators: @emg110.algo
// Github: https://github.com/GoraNetwork/gora-dao-smartcontracts
/////////////////////////////////////////////////////////////////

#pragma version 8

//Check TXN first
callsub sub_check_txn

// Checking onCompletion type for delete application call
// txn OnCompletion
// int DeleteApplication
// ==
// txn ApplicationID
// int 0
// !=
// &&
// bnz branch_delete

// Checking onCompletion type for close out application call
// txn OnCompletion
// int CloseOut
// !=
// assert


// Checking onCompletion type for optin application call
// txn OnCompletion
// int OptIn
// !=
// assert
txn OnCompletion
int NoOp
==
txn OnCompletion
int UpdateApplication
==
||
assert

// Checks the number of application args , if 0 then no method it is
txn NumAppArgs
int 0
==
bz branch_method_router
b branch_error

///////////////////////////////////////////
branch_method_router:

	method "create_staking(uint64,uint64,string,string)address"
	txn ApplicationArgs 0
	==
	txn ApplicationID
	int 0
	==
	&&
	bnz method_create_staking

	method "update_staking()address"
	txn ApplicationArgs 0
	==
	bnz method_update_staking

	method "config_staking(pay,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),string,string,string,string,uint64,uint64)uint64"
	txn ApplicationArgs 0
	==
	bnz method_config_staking

	method "update_manager_address(pay,byte[],byte[])string"
	txn ApplicationArgs 0
	==
	bnz method_update_manager_address

	method "activate_staking()uint64"
	txn ApplicationArgs 0
	==
	bnz method_activate_staking


	// method "optin_staking(uint64)uint64"
	// txn ApplicationArgs 0
	// ==
	// bnz method_optin_staking

	method "stake(pay,axfer)uint64"
	txn ApplicationArgs 0
	==
	bnz method_staking_stake

    method "unstake()uint64"
	txn ApplicationArgs 0
	==
	bnz method_staking_unstake



	b branch_error

///////////////////////////////////////////
// Subroutine to handle transaction checks
sub_check_txn:

	// Checks RekeyTo address transaction field to be empty (ZeroAddress)
	txn RekeyTo
	global ZeroAddress
	==
	assert

	// Checks CloseRemainderTo address transaction field to be empty (ZeroAddress)
	txn CloseRemainderTo
	global ZeroAddress
	==
	assert

	// Checks AssetCloseTo address transaction field to be empty (ZeroAddress)
	txn AssetCloseTo
	global ZeroAddress
	==
	assert

	// Check transaction type to be application call
	txn TypeEnum
	int appl
	==
	bz branch_error

	// Checking transaction fee
	txn Fee
	global MinTxnFee
	>=
	assert
	retsub

// Checks owner address authentication
sub_check_owner_auth:

	txn Sender
	global CreatorAddress
	==
	assert
	retsub

// Checks manager address authentication
sub_check_manager_auth:
	txn Sender
	byte "manager_address"
	app_global_get
	==
	assert
	retsub
	

// Handles creation of Staking contract
method_create_staking:

	global CurrentApplicationID
	store 0

	txna Applications 1
	store 1
	byte "dao_app_id"
	load 1
	app_global_put


	txna ApplicationArgs 1
	btoi
	store 2
	byte "dao_asset_id"
	load 2
	app_global_put

	txn ApplicationArgs 2
	btoi
	store 3
	byte "asset_id"
	load 3
	app_global_put

	txna Accounts 1
	store 4
	byte "manager_address"
	load 4
	app_global_put

	txna Accounts 2
	store 5
	byte "dao_manager_address"
	load 5
	app_global_put

	txn ApplicationArgs 3
	store 6
	byte "name"
	load 6
	app_global_put

	txn ApplicationArgs 4
	store 7
	byte "description"
	load 7
	app_global_put

	byte "stakings_count"
	int 0
	app_global_put

	byte "is_activated"
	int 0
	app_global_put

	byte "staked_amount_algo"
	int 0
	app_global_put

	byte "staked_amount_token"
	int 0
	app_global_put

	byte 0x151f7c75
	global CurrentApplicationAddress
	concat
	b branch_log_return

// Handles updating of Staking contract
method_update_staking:
	callsub sub_check_owner_auth
	byte 0x151f7c75
	global CurrentApplicationAddress
	concat
	b branch_log_return

// Handles updating of a staking contract manager address
method_update_manager_address:
	callsub sub_check_manager_auth

	txn ApplicationArgs 1
	byte "manager_address"
	app_global_put

	byte 0x151f7c75
	byte "Staking manager address is now updated!"
	concat
	b branch_log_return

// Handles activation of Staking
method_activate_staking:
	callsub sub_check_manager_auth
	byte "is_activated"
	int 1
	app_global_put

	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return

// Handles configuration of Staking
method_config_staking:
	callsub sub_check_manager_auth

	byte "manager_address"
	txn Sender
	app_global_put
	
	gtxn 0 TypeEnum
	int pay
	==
	bz branch_error

	gtxn 0 Amount
	int 500000
	>=
	assert

	gtxn 0 Receiver
	global CurrentApplicationAddress
	==
	assert

	txn ApplicationArgs 1 
	store 0

	load 0
	int 0
	extract_uint64 //staking_min_algo
	store 1
	byte "min_algo"
	load 1
	app_global_put
	//log

	load 0
	int 8
	extract_uint64 //staking_min_token
	store 2
	byte "min_token"
	load 2
	app_global_put
	//log

	load 0
	int 16
	extract_uint64 //staking_duration
	store 3
	byte "duration"
	load 3
	app_global_put
	//log

	load 0
	int 24
	extract_uint64 //staking_min_duration
	store 4
	byte "min_duration"
	load 4
	app_global_put
	//log

	load 0
	int 32
	extract_uint64 //staking_commission_percentage
	store 5
	byte "commission_token"
	load 5
	app_global_put
	//log

	load 0
	int 40
	extract_uint64 //staking_commission_percentage_algo
	store 6
	byte "commission_algo"
	load 6
	app_global_put
	//log

	load 0
	int 48
	extract_uint64 //staking_fee_token
	store 7
	byte "fee_token"
	load 7
	app_global_put
	//log

	load 0
	int 56
	extract_uint64 //staking_fee_algo
	store 8
	byte "fee_algo"
	load 8
	app_global_put
	//log

	load 0
	int 64
	extract_uint64 //staking_incentives_percentage
	store 9
	byte "incentives_token"
	load 9
	app_global_put
	//log

	load 0
	int 72
	extract_uint64 //staking_incentives_percentage_algo
	store 26
	byte "incentives_algo"
	load 26
	app_global_put
	//log

	load 0
	int 80
	extract_uint64 //staking_type
	store 10
	byte "type"
	load 10
	app_global_put
	//log

	load 0
	int 88
	extract_uint64 //staking_incentives_duration
	store 11
	byte "incentives_duration"
	load 11
	app_global_put
	//log

	load 0
	int 96
	extract_uint64 //staking_return_percentage
	store 12
	byte "return_token"
	load 12
	app_global_put
	//log

	load 0
	int 104
	extract_uint64 //staking_return_percentage_algo
	store 13
	byte "return_algo"
	load 13
	app_global_put
	//log

	// load 0
	// int 112
	// extract_uint64 //staking_proxy_app_is_whitelisted
	// store 24
	// byte "is_whitelisted"
	// load 24
	// app_global_put
	//log

	// load 0
	// int 120
	// extract_uint64 //staking_proxy_app_is_pending
	// store 25
	// byte "proxy_app_is_pending"
	// load 25
	// app_global_put
	//log

	load 0
	int 112
	extract_uint64 //staking_incentives_eligibility
	store 27
	byte "incentives_eligibility"
	load 27
	app_global_put
	//log

	txn ApplicationArgs 2 //staking_name
	store 14
	byte "name"
	load 14
	app_global_put
	//log

	txn ApplicationArgs 3 //staking_description
	store 15
	byte "description"
	load 15
	app_global_put
	//log

	txn ApplicationArgs 4 //staking_url
	store 16
	byte "url"
	load 16
	app_global_put
	//log

	txn ApplicationArgs 5 //staking_banner
	store 17
	byte "banner"
	load 17
	app_global_put
	//log

	// txn ApplicationArgs 6 //staking_proxy_app_id
	// btoi
	// store 18
	// byte "proxy_app_id"
	// load 18
	// app_global_put
	//log

	// txn ApplicationArgs 7 //staking_proxy_app_address
	// store 19
	// byte "proxy_app_address"
	// load 19
	// app_global_put
	//log

	// txn ApplicationArgs 8 //staking_proxy_app_creator
	// store 20
	// byte "proxy_app_creator"
	// load 20
	// app_global_put
	//log

	// txn ApplicationArgs 9 //staking_proxy_app_manager
	// store 21
	// byte "proxy_app_manager"
	// load 21
	// app_global_put
	//log

	// txn ApplicationArgs 10 //staking_proxy_app_created_at
	// store 22
	// byte "proxy_app_created_at"
	// load 22
	// app_global_put
	//log

	// txn ApplicationArgs 11 //staking_proxy_app_updated_at
	// store 23
	// byte "proxy_app_updated_at"
	// load 23
	// app_global_put
	//log

	// txn ApplicationArgs 12 //staking_proxy_participating_address
	// store 26
	// byte "proxy_participating_address"
	// load 26
	// app_global_put

	// byte "proxy_staking_vesting_app_id"
	// global CurrentApplicationID
	// app_global_put

	txn ApplicationArgs 6 //v2_main_app_id
	btoi
	byte "v2_main_app_id"
	swap
	app_global_put

	txn ApplicationArgs 7 //v2_vesting_app_id
	btoi
	byte "v2_vesting_app_id"
	swap
	app_global_put

	itxn_begin
	global CurrentApplicationAddress
	itxn_field Sender
	int axfer
	itxn_field TypeEnum
	global CurrentApplicationAddress
	itxn_field AssetReceiver
	int 0
	itxn_field AssetAmount
	txna Assets 0
	itxn_field XferAsset
	itxn_submit
	itxn TxID
    log

	global CurrentApplicationAddress
	txna Applications 2
	app_opted_in
	bz branch_optin_config

branch_optin_finalize:
	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return

sub_optin_v2:
	itxn_begin
	global CurrentApplicationAddress
	itxn_field Sender
	int appl
	itxn_field TypeEnum
	int 1
	itxn_field OnCompletion

	method "opt_in(uint64)void"
	itxn_field ApplicationArgs

	txna Applications 2
	itxn_field ApplicationID

	byte "v2_vesting_app_id"
	app_global_get
	itob
	itxn_field ApplicationArgs
	itxn_submit
	retsub

branch_optin_config:
	callsub sub_optin_v2
	b branch_optin_finalize

branch_optin_staking:
	callsub sub_optin_v2
	b branch_stake_in_proxy


branch_user_box:
	load 1
	load 5
	itob
	load 6
	itob
	concat
	box_put
	
		


branch_stake_in_proxy:
	global CurrentApplicationAddress
	txna Applications 1
	app_opted_in
	bz branch_optin_staking

	load 1 //TXN sender
	txna Assets 0
	asset_holding_get AssetBalance
	int 1
	>=
	assert
	
	// Staking V2 Asset Transfer inner transaction: asset_pay
	itxn_begin
	// global CurrentApplicationAddress
	// itxn_field Sender
	txna Accounts 1
	itxn_field AssetReceiver
	int axfer
	itxn_field TypeEnum
	gtxn 4 XferAsset
	itxn_field XferAsset
	load 6
	itxn_field AssetAmount

	// Proxied staking V2 Application ABI call for stake
	itxn_next
	txna Applications 1
	itxn_field ApplicationID
	global CurrentApplicationAddress
	itxn_field Sender
	int NoOp
	itxn_field OnCompletion
	int appl
	itxn_field TypeEnum
	method "stake(axfer,account,application,asset,account)void"
	itxn_field ApplicationArgs // method
	// txn Sender // Staking end user account
	// itxn_field Accounts
	txna Accounts 2 // staking_proxy_app_manager
	itxn_field Accounts
	txna Assets 0 // staking_asset_id
	itxn_field Assets
	// byte "\x01" // Staking end user account
	global ZeroAddress
	itxn_field ApplicationArgs //vesting_on_behalf_of
	byte "v2_main_app_id"
	app_global_get
	itob
	itxn_field ApplicationArgs //main_app_ref
	byte "asset_id"
	app_global_get
	itob
	itxn_field ApplicationArgs //asset_ref
	txna Accounts 2
	itxn_field ApplicationArgs //manager_reference
	txna Applications 1
	itxn_field Applications//staking_proxy_app_id
	txna Applications 2
	itxn_field Applications //proxy_staking_main_app_id
	int 15000
	itxn_field Fee
	itxn_submit
	b branch_staking_stake_finalize

method_staking_stake:
	txna Accounts 0 // DAO main account
	store 0 
	txn Sender // Staking user account
	store 1 

	// Checking the staking activation
	byte "is_activated"
	app_global_get
	bz branch_error_activation

	// Checking the asset ref to be Staking asset ID
    byte "asset_id"
    app_global_get
	dup
    gtxn 1 XferAsset
    ==
    assert
	gtxn 4 XferAsset
	==
	assert

	// Checking staking minimum participation algos
	gtxn 3 Amount // The staked amount algo
	store 5 
	

	// Checking staking minimum participation tokens
    gtxn 4 AssetAmount // The staked amount token
	store 6 

	int 0
	dup
	store 11
	store 12


    // Checking staked algo amount box 
	load 1
	box_get
	bz branch_stake_continue
	store 10
	load 10
	int 0
	extract_uint64
	store 11
	load 11
	itob
	log
	load 10
	int 8
	extract_uint64
	store 12
	load 12
	itob
	log

	load 1
	box_del
	assert


branch_stake_continue:
	// Staking finalization and account boxes staking values update
	load 1
	load 11
	load 5
	+
	itob
	load 12
	load 6
	+
	itob
	concat
	box_put

	// Stats update
	byte "stakings_count"
	dup
	app_global_get
	int 1
	+
	app_global_put

	byte "staked_amount_algo"
	app_global_get
	load 5
	+ // The total staked amount algo
	byte "staked_amount_algo"
	swap
	app_global_put

	byte "staked_amount_token"
	app_global_get
	load 6
	+// The total staked amount token
	byte "staked_amount_token"
	swap
	app_global_put

	byte "type"
	app_global_get
	int 0
	>
	bnz branch_stake_in_proxy

branch_staking_stake_finalize:
	// Log and return
	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return

branch_unstake_from_proxy:
	// Proxied staking V2 Application ABI call for unstake
	itxn_begin
	txna Applications 1
	itxn_field ApplicationID
	global CurrentApplicationAddress
	itxn_field Sender
	int NoOp
	itxn_field OnCompletion
	int appl
	itxn_field TypeEnum
	method "unstake(uint64,application,asset,account)void"
	itxn_field ApplicationArgs // method
	load 6
	itob
	itxn_field ApplicationArgs 
	byte "v2_main_app_id"
	app_global_get
	itob
	itxn_field ApplicationArgs //main_app_ref
	byte "asset_id"
	app_global_get
	itob
	itxn_field ApplicationArgs //asset_ref
	txna Accounts 2 // staking_proxy_app_manager
	itxn_field ApplicationArgs //manager_reference


	itxn_field Accounts
	txna Assets 0 // staking_asset_id
	itxn_field Assets
	

	txna Applications 1
	itxn_field Applications//v2_app_id

	txna Applications 2
	itxn_field Applications //v2_main_app_id
	int 2000
	itxn_field Fee
	itxn_submit
	b branch_staking_unstake_finalize
	
method_staking_unstake:
	txna Accounts 0 // DAO main account
	store 0 
	txn Sender // Staking user account
	store 1 

	// Checking the staking activation
	byte "is_activated"
	app_global_get
	bz branch_error_activation

	// Checking the asset ref to be Staking asset ID
    byte "asset_id"
    app_global_get
	dup
    gtxn 1 XferAsset
    ==
    assert
	gtxn 4 XferAsset
	==
	assert

	// Checking staking minimum participation algos
	gtxn 3 Amount // The staked amount algo
	store 5 
	

	// Checking staking minimum participation tokens
    gtxn 4 AssetAmount // The staked amount token
	store 6 

	int 0
	dup
	store 11
	store 12


    // Checking staked algo amount box 
	load 1
	box_get
	assert

	store 10 // Staked amounts algos from account box
	load 10
	int 0
	extract_uint64
	store 11
	load 11
	itob
	log
	load 10
	int 8
	extract_uint64
	store 12
	load 12
	itob
	log

	load 1
	box_del
	assert


	// Staking finalization and account boxes staking values update
	load 1
	load 11
	load 5
	-
	itob
	load 12
	load 6
	-
	itob
	concat
	box_put

	// Stats update

	byte "staked_amount_algo"
	app_global_get
	load 5
	- // The total staked amount algo
	byte "staked_amount_algo"
	swap
	app_global_put

	byte "staked_amount_token"
	app_global_get
	load 6
	-// The total staked amount token
	byte "staked_amount_token"
	swap
	app_global_put

	byte "type"
	app_global_get
	int 0
	>
	bnz branch_unstake_from_proxy
branch_staking_unstake_finalize:
	// Log and return
	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return


// Handles logging the last element on the stack then put a 1 on the top and return (log and approve)
branch_log_return:
	log
	int 1
	return

branch_error:
	err
branch_error_activation:
	err

