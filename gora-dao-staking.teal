// Gora DAO Staking Smart Contract
// Version 1
// Website: https://www.gora.io/
// Creators: @emg110.algo
// Github: https://github.com/GoraNetwork/gora-dao-smartcontracts
/////////////////////////////////////////////////////////////////

#pragma version 8

//Check TXN first
callsub sub_check_txn

txn OnCompletion
int NoOp
==
txn OnCompletion
int UpdateApplication
==
||
assert

// Checks the number of application args , if 0 then no method it is
txn NumAppArgs
int 0
==
bz branch_method_router
b branch_error

///////////////////////////////////////////
branch_method_router:

	method "create_staking(uint64,uint64,string,string)address"
	txn ApplicationArgs 0
	==
	txn ApplicationID
	int 0
	==
	&&
	bnz method_create_staking

	method "update_staking()address"
	txn ApplicationArgs 0
	==
	bnz method_update_staking

	method "config_staking(pay,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),string,string,string,string,uint64,uint64)uint64"
	txn ApplicationArgs 0
	==
	bnz method_config_staking

	method "update_manager_address(pay,byte[],byte[])string"
	txn ApplicationArgs 0
	==
	bnz method_update_manager_address

	method "activate_staking()uint64"
	txn ApplicationArgs 0
	==
	bnz method_activate_staking


	// method "optin_staking(uint64)uint64"
	// txn ApplicationArgs 0
	// ==
	// bnz method_optin_staking

	method "stake(pay,axfer,uint64)uint64"
	txn ApplicationArgs 0
	==
	bnz method_staking_stake

    method "unstake(uint64,uint64,uint64)uint64"
	txn ApplicationArgs 0
	==
	bnz method_staking_unstake

	method "withdraw()uint64"
	txn ApplicationArgs 0
	==
	bnz method_withdraw_unstaked

	

	method "register_nft(uint64,uint64)uint64"
	txn ApplicationArgs 0
	==
	bnz method_register_nft

	method "user_claim()uint64"
	txn ApplicationArgs 0
	==
	bnz method_register_nft



	
	b branch_error

///////////////////////////////////////////
// Subroutine to handle transaction checks
sub_check_txn:

	// Checks RekeyTo address transaction field to be empty (ZeroAddress)
	txn RekeyTo
	global ZeroAddress
	==
	assert

	// Checks CloseRemainderTo address transaction field to be empty (ZeroAddress)
	txn CloseRemainderTo
	global ZeroAddress
	==
	assert

	// Checks AssetCloseTo address transaction field to be empty (ZeroAddress)
	txn AssetCloseTo
	global ZeroAddress
	==
	assert

	// Check transaction type to be application call
	txn TypeEnum
	int appl
	==
	bz branch_error

	// Checking transaction fee
	txn Fee
	global MinTxnFee
	>=
	assert
	retsub

// Checks owner address authentication
sub_check_owner_auth:

	txn Sender
	global CreatorAddress
	==
	assert
	retsub

// Checks manager address authentication
sub_check_manager_auth:
	txn Sender
	byte "manager_address"
	app_global_get
	==
	assert
	retsub
	

// Handles creation of Staking contract
method_create_staking:

	global CurrentApplicationID
	store 0

	txna Applications 1
	store 1
	byte "dao_app_id"
	load 1
	app_global_put


	txna ApplicationArgs 1
	btoi
	store 2
	byte "dao_asset_id"
	load 2
	app_global_put

	txn ApplicationArgs 2
	btoi
	store 3
	byte "asset_id"
	load 3
	app_global_put

	txna Accounts 1
	store 4
	byte "manager_address"
	load 4
	app_global_put

	txna Accounts 2
	store 5
	byte "dao_manager_address"
	load 5
	app_global_put

	txn ApplicationArgs 3
	store 6
	byte "name"
	load 6
	app_global_put

	txn ApplicationArgs 4
	store 7
	byte "description"
	load 7
	app_global_put

	byte "stakings_count"
	int 0
	app_global_put

	byte "is_activated"
	int 0
	app_global_put

	byte "staked_amount_algo"
	int 0
	app_global_put

	byte "staked_amount_token"
	int 0
	app_global_put

	byte "staked_nft_count"
	int 0
	app_global_put

	byte "staked_nft_value"
	int 0
	app_global_put

	byte 0x151f7c75
	global CurrentApplicationAddress
	concat
	b branch_log_return

// Handles updating of Staking contract
method_update_staking:
	callsub sub_check_owner_auth
	byte 0x151f7c75
	global CurrentApplicationAddress
	concat
	b branch_log_return

// Handles updating of a staking contract manager address
method_update_manager_address:
	callsub sub_check_manager_auth

	txn ApplicationArgs 1
	byte "manager_address"
	app_global_put

	byte 0x151f7c75
	byte "Staking manager address is now updated!"
	concat
	b branch_log_return

// Handles activation of Staking
method_activate_staking:
	callsub sub_check_manager_auth
	byte "is_activated"
	int 1
	app_global_put

	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return

// Handles configuration of Staking
method_config_staking:
	callsub sub_check_manager_auth

	byte "manager_address"
	txn Sender
	app_global_put
	
	gtxn 0 TypeEnum
	int pay
	==
	bz branch_error

	gtxn 0 Amount
	int 500000
	>=
	assert

	gtxn 0 Receiver
	global CurrentApplicationAddress
	==
	assert

	txn ApplicationArgs 1 
	store 0

	load 0
	int 0
	extract_uint64 //staking_min_algo
	store 1
	byte "min_algo"
	load 1
	app_global_put


	load 0
	int 8
	extract_uint64 //staking_min_token
	store 2
	byte "min_token"
	load 2
	app_global_put


	load 0
	int 16
	extract_uint64 //staking_duration
	store 3
	byte "duration"
	load 3
	app_global_put


	load 0
	int 24
	extract_uint64 //staking_min_duration
	store 4
	byte "min_duration"
	load 4
	app_global_put


	load 0
	int 32
	extract_uint64 //staking_commission_percentage
	store 5
	byte "commission_token"
	load 5
	app_global_put


	load 0
	int 40
	extract_uint64 //staking_commission_percentage_algo
	store 6
	byte "commission_algo"
	load 6
	app_global_put


	load 0
	int 48
	extract_uint64 //staking_fee_token
	store 7
	byte "fee_token"
	load 7
	app_global_put


	load 0
	int 56
	extract_uint64 //staking_fee_algo
	store 8
	byte "fee_algo"
	load 8
	app_global_put


	// load 0
	// int 64
	// extract_uint64 //staking_incentives_percentage
	// store 9
	// byte "incentives_token"
	// load 9
	// app_global_put


	// load 0
	// int 72
	// extract_uint64 //staking_incentives_percentage_algo
	// store 26
	// byte "incentives_algo"
	// load 26
	// app_global_put


	load 0
	int 80
	extract_uint64 //staking_type
	store 10
	byte "type"
	load 10
	app_global_put


	// load 0
	// int 88
	// extract_uint64 //staking_incentives_duration
	// store 11
	// byte "incentives_duration"
	// load 11
	// app_global_put


	load 0
	int 96
	extract_uint64 //staking_return_percentage
	store 12
	byte "return_token"
	load 12
	app_global_put


	load 0
	int 104
	extract_uint64 //staking_return_percentage_algo
	store 13
	byte "return_algo"
	load 13
	app_global_put


	// load 0
	// int 112
	// extract_uint64 //staking_incentives_eligibility
	// store 27
	// byte "incentives_eligibility"
	// load 27
	// app_global_put


	txn ApplicationArgs 2 //staking_name
	store 14
	byte "name"
	load 14
	app_global_put


	txn ApplicationArgs 3 //staking_description
	store 15
	byte "description"
	load 15
	app_global_put


	// txn ApplicationArgs 4 //staking_url
	// store 16
	// byte "url"
	// load 16
	// app_global_put
	// //log

	// txn ApplicationArgs 5 //staking_banner
	// store 17
	// byte "banner"
	// load 17
	// app_global_put
	//log

	

	txn ApplicationArgs 6 //v2_main_app_id
	btoi
	byte "v2_main_app_id"
	swap
	app_global_put

	txn ApplicationArgs 7 //v2_vesting_app_id
	btoi
	byte "v2_vesting_app_id"
	swap
	app_global_put

	itxn_begin
	global CurrentApplicationAddress
	itxn_field Sender
	int axfer
	itxn_field TypeEnum
	global CurrentApplicationAddress
	itxn_field AssetReceiver
	int 0
	itxn_field AssetAmount
	txna Assets 0
	itxn_field XferAsset
	itxn_submit
	//itxn TxID


	global CurrentApplicationAddress
	txna Applications 2
	store 22
	load 22
	app_opted_in
	bz branch_optin_config

branch_optin_finalize:
	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return

sub_optin_v2:
	itxn_begin
	global CurrentApplicationAddress
	itxn_field Sender
	int appl
	itxn_field TypeEnum
	int 1
	itxn_field OnCompletion

	method "opt_in(uint64)void"
	itxn_field ApplicationArgs

	load 22
	itxn_field ApplicationID

	byte "v2_vesting_app_id"
	app_global_get
	itob
	itxn_field ApplicationArgs
	itxn_submit
	retsub

branch_optin_config:
	callsub sub_optin_v2
	b branch_optin_finalize

branch_optin_staking:
	callsub sub_optin_v2
	b branch_stake_in_proxy
	
		
branch_stake_in_proxy:
	global CurrentApplicationAddress
	txna Applications 1
	store 22
	load 22
	app_opted_in
	bz branch_optin_staking

	load 1 //TXN sender
	txna Assets 0
	asset_holding_get AssetBalance
	int 1
	>=
	assert
	
	// Staking V2 Asset Transfer inner transaction: asset_pay
	itxn_begin
	txna Accounts 1
	itxn_field AssetReceiver
	int axfer
	itxn_field TypeEnum
	gtxn 4 XferAsset
	itxn_field XferAsset
	load 6
	itxn_field AssetAmount
	itxn_next
	txna Applications 1
	itxn_field ApplicationID
	// global CurrentApplicationAddress
	// itxn_field Sender
	// int NoOp
	// itxn_field OnCompletion
	int appl
	itxn_field TypeEnum
	method "stake(axfer,account,application,asset,account)void"
	itxn_field ApplicationArgs // method
	byte base64 AQ==
	itxn_field ApplicationArgs //vesting_on_behalf_of
	// byte "v2_main_app_id"
	// app_global_get
	// itob
	byte base64 AQ==
	itxn_field ApplicationArgs //main_app_ref
	// byte "asset_id"
	// app_global_get
	// itob
	byte base64 AA==
	itxn_field ApplicationArgs //asset_ref
	byte base64 Ag==
	itxn_field ApplicationArgs //manager_reference

	global ZeroAddress
	itxn_field Accounts

	txna Accounts 2 // staking_proxy_app_manager
	itxn_field Accounts
	txna Assets 0 // staking_asset_id
	itxn_field Assets
	// txna Applications 1
	// itxn_field Applications//staking_proxy_app_id
	txna Applications 2
	itxn_field Applications //proxy_staking_main_app_id
	int 15000
	itxn_field Fee
	itxn_submit
	b branch_staking_stake_finalize

method_staking_stake:
	txna Accounts 0 // DAO main account
	store 0 
	txn Sender // Staking user account
	store 1
	load 1
	txna Applications 1
	itob
	concat
	store 21

	// NFT Box read
	txn ApplicationArgs 1
	box_get
	assert
	store 23
	load 23
	int 0
	extract_uint64
	store 24 // NFT Staking value
	
	
	load 23
	int 8
	extract_uint64
	store 25 // NFT Staking isLocked
	load 25
	int 0
	==
	assert 

	

	// Checking the staking activation
	byte "is_activated"
	app_global_get
	bz branch_error_activation

	// Checking the asset ref to be Staking asset ID
    byte "asset_id"
    app_global_get
	dup
    gtxn 1 XferAsset
    ==
    assert
	gtxn 4 XferAsset
	==
	assert

	// Checking staking minimum participation algos
	gtxn 3 Amount // The staked amount algo
	store 5 
	

	// The delegator+V2AppID box write
    gtxn 4 AssetAmount // The staked amount token
	load 24
	int 1000000000
	*
	+
	store 6 

	txn ApplicationArgs 1
	load 24
	itob
	int 1
	itob
	concat
	txna Applications 1
	itob
	concat
	global LatestTimestamp
	itob
	concat
	box_put

	int 0
	dup
	store 11
	store 12

	int 0
	dup
	store 13
	store 14


    // Checking staked algo amount box 
	load 21
	box_get
	bz branch_stake_continue
	store 10
	load 10
	int 0
	extract_uint64
	store 11

	load 10
	int 8
	extract_uint64
	store 12


	load 10
	int 16
	extract_uint64
	store 13


	load 10
	int 24
	extract_uint64
	store 14
	

	load 21
	box_del
	assert


branch_stake_continue:
	// Staking finalization and account boxes staking values update
	load 21
	load 11
	load 5
	+
	itob
	load 12
	load 6
	+
	itob
	concat
	load 13
	itob
	load 14
	itob
	concat
	concat
	box_put

	// Stats update
	byte "stakings_count"
	dup
	app_global_get
	int 1
	+
	app_global_put

	byte "staked_amount_algo"
	app_global_get
	load 5
	+ // The total staked amount algo
	byte "staked_amount_algo"
	swap
	app_global_put

	byte "staked_amount_token"
	app_global_get
	load 6
	+// The total staked amount token
	byte "staked_amount_token"
	swap
	app_global_put

	byte "type"
	app_global_get
	int 0
	>
	bnz branch_stake_in_proxy

branch_staking_stake_finalize:
	// Log and return
	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return

branch_unstake_from_proxy:
	// Proxied staking V2 Application ABI call for unstake
	itxn_begin
	txna Applications 1
	itxn_field ApplicationID
	global CurrentApplicationAddress
	itxn_field Sender
	int NoOp
	itxn_field OnCompletion
	int appl
	itxn_field TypeEnum
	method "unstake(uint64,application,asset,account)void"
	itxn_field ApplicationArgs // method
	load 6
	itob
	itxn_field ApplicationArgs 
	byte base64 AQ==
	itxn_field ApplicationArgs //main_app_ref
	byte base64 AA==
	itxn_field ApplicationArgs //asset_ref
	byte base64 AQ== // staking_proxy_app_manager
	itxn_field ApplicationArgs //manager_reference

	txna Accounts 2
	itxn_field Accounts
	txna Assets 0 // staking_asset_id
	itxn_field Assets
	

	txna Applications 1
	itxn_field Applications//v2_app_id

	txna Applications 2
	itxn_field Applications //v2_main_app_id
	int 2000
	itxn_field Fee
	itxn_submit
	b branch_staking_unstake_finalize
branch_unstake_without_rewards:
	load 21	
	load 11
	load 5
	-
	itob
	load 12
	load 6
	-
	itob
	concat	
	load 13
	itob
	load 14
	itob
	concat 
	concat
	box_put

	byte "type"
	app_global_get
	int 0
	>
	bnz branch_unstake_from_proxy
	b branch_staking_unstake_finalize
method_staking_unstake:
	txna Accounts 0 // DAO main account
	store 0 
	txn Sender // Staking user account
	store 1 
	load 1
	txna Applications 1
	itob
	concat
	store 21 // The Delegator+V2AppID box key

	// Checking the staking activation
	byte "is_activated"
	app_global_get
	bz branch_error_activation
	// NFT Box
	txn ApplicationArgs 3
	box_get
	assert
	store 23
	load 23
	int 0
	extract_uint64
	store 24

	load 23
	int 8
	extract_uint64
	int 1
	==
	assert

	global LatestTimestamp
	load 23
	int 24
	extract_uint64
	store 30
	load 30
	-
	byte "min_duration"
	app_global_get
	>
	assert


	
	
	txn ApplicationArgs 3
	load 24
	itob
	int 0
	itob
	concat
	int 0
	itob
	concat
	int 0
	itob
	concat
	box_put



	txn ApplicationArgs 1 // The unstaked amount algo
	btoi
	store 5 
	


    txn ApplicationArgs 2 // The token amount to unstake
	btoi
	load 24
	int 1000000000
	*
	+
	store 6 


    // Checking staked algo amount box 
	load 21
	box_get
	assert

	store 10 // Staked amounts algos from account box
	load 10
	int 0
	extract_uint64
	store 11
	
	load 10
	int 8
	extract_uint64
	store 12


	load 10
	int 16
	extract_uint64
	store 13


	load 10
	int 24
	extract_uint64
	store 14
	

	load 21
	box_del
	assert

	global LatestTimestamp
	load 30
	-
	store 33
	load 33
	byte "duration"
	app_global_get
	>=
	bnz branch_unstake_without_rewards

	
branch_unstake_with_rewards:
	//Calc rewards
	int 17
	load 6
	*
	int 100
	/
	int 31536000
	/
	load 33
	*
	store 39

	load 21
	load 11
	load 5
	-
	itob
	load 12
	load 6
	-
	itob
	concat	
	load 13
	load 5
	+
	itob
	load 39
	itob
	concat 
	concat
	box_put

	
	byte "type"
	app_global_get
	int 0
	>
	bnz branch_unstake_from_proxy

branch_staking_unstake_finalize:
	// Log and return
	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return


branch_withdraw_from_proxy:
	txn Sender
	txna Assets 0
	asset_holding_get AssetBalance
	int 1
	>=
	assert

	itxn_begin
	txna Applications 1
	itxn_field ApplicationID
	global CurrentApplicationAddress
	itxn_field Sender
	int NoOp
	itxn_field OnCompletion
	int appl
	itxn_field TypeEnum
	method "manual_process_aggregation(asset,application,account)void"
	itxn_field ApplicationArgs // method
	byte base64 AA==
	itxn_field ApplicationArgs //asset_ref
	byte base64 AQ==
	itxn_field ApplicationArgs //main_app_ref
	byte base64 AQ==
	itxn_field ApplicationArgs //manager_reference
	txna Accounts 2 // staking_proxy_app_manager
	itxn_field Accounts
	txna Assets 0 // staking_asset_id
	itxn_field Assets
	txna Applications 2
	itxn_field Applications //proxy_staking_main_app_id
	int 2000
	itxn_field Fee
	itxn_submit

	itxn_begin
	txna Applications 1
	itxn_field ApplicationID
	global CurrentApplicationAddress
	itxn_field Sender
	int NoOp
	itxn_field OnCompletion
	int appl
	itxn_field TypeEnum
	method "withdraw_non_stake(account,asset,application,account)void"
	itxn_field ApplicationArgs // method
	byte base64 AQ==
	itxn_field ApplicationArgs //vesting_on_behalf_of
	byte base64 AA==
	itxn_field ApplicationArgs //asset_ref
	byte base64 AQ==
	itxn_field ApplicationArgs //main_app_ref
	byte base64 Ag==
	itxn_field ApplicationArgs //manager_reference

	global ZeroAddress
	itxn_field Accounts
	txna Accounts 2 // staking_proxy_app_manager
	itxn_field Accounts
	txna Assets 0 // staking_asset_id
	itxn_field Assets

	txna Applications 2
	itxn_field Applications //proxy_staking_main_app_id
	int 15000
	itxn_field Fee
	itxn_submit
	b branch_withdraw_finalize

sub_user_claim:
	txn Sender // Staking user account
	store 1 
	load 1
	txna Applications 1
	itob
	concat
	store 21 // The Delegator+V2AppID box key

	 // Checking staked algo amount box 
	load 21
	box_get
	assert

	store 10 // Staked amounts algos from account box
	load 10
	int 0
	extract_uint64
	store 11

	load 10
	int 8
	extract_uint64
	store 12
	
	load 10
	int 16
	extract_uint64
	store 13
	

	load 10
	int 24
	extract_uint64
	store 14
	

	load 21
	box_del
	assert
	// itxn_begin
	// txn Sender
	// itxn_field AssetReceiver
	// int axfer
	// itxn_field TypeEnum
	// txna Assets 0
	// itxn_field XferAsset
	// load 6
	// itxn_field AssetAmount
	// itxn_submit

method_withdraw_unstaked:
	txna Accounts 0 // DAO main account
	store 0 
	txn Sender // Staking user account
	store 1 
	load 1
	txna Applications 1
	itob
	concat
	store 21

	int 0
	dup
	store 11
	store 12

	// Checking the staking activation
	byte "is_activated"
	app_global_get
	bz branch_error_activation

	load 21
	box_get
	assert

	store 10 // Delegator+V2AppId box 
	load 10
	int 0
	extract_uint64
	store 11 // Staked Algos
	
	load 10
	int 8
	extract_uint64
	store 12 // Staked tokens


	load 10
	int 16
	extract_uint64
	store 13 //Unstaked Algos
	
	load 10
	int 24
	extract_uint64
	store 14 // Unstaked tokens


	load 21
	box_del
	assert

	load 21

	load 11
	itob
	load 12 
	itob
	concat
	load 13
	itob
	load 14
	itob
	concat
	concat
	box_put

	byte "type"
	app_global_get
	int 0
	>
	bnz branch_withdraw_from_proxy

branch_withdraw_finalize:
	// Log and return
	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return

method_register_nft:
	callsub sub_check_manager_auth
	byte "staked_nft_count"
	dup
	app_global_get
	int 1
	+
	app_global_put

	byte "staked_nft_value"
	dup
	app_global_get
	txn ApplicationArgs 2
	btoi
	+
	app_global_put

	txn ApplicationArgs 1
	store 0

	txn ApplicationArgs 2
	int 0
	itob
	concat
	int 0
	itob
	concat
	int 0
	itob
	concat
	store 1

	load 0
	box_get
	bnz branch_nft_box
	load 0
	load 1
	box_put



	

branch_nft_box:
	load 0
	box_del
	assert
	load 0
	load 1
	box_put
	

	byte 0x151f7c75
	txn ApplicationArgs 1
	concat
	b branch_log_return

	


// Handles logging the last element on the stack then put a 1 on the top and return (log and approve)
branch_log_return:
	log
	int 1
	return

branch_error:
	err
branch_error_activation:
	err

