// Gora DAO Staking Smart Contract
// Version 1
// Website: https://www.gora.io/
// Creators: @emg110.algo
// Github: https://github.com/GoraNetwork/gora-dao-smartcontracts
/////////////////////////////////////////////////////////////////

#pragma version 8

//Check TXN first
callsub sub_check_txn

// Checking onCompletion type for delete application call
txn OnCompletion
int DeleteApplication
==
txn ApplicationID
int 0
!=
&&
bnz branch_delete

// Checking onCompletion type for close out application call
txn OnCompletion
int CloseOut
==
txn ApplicationID
int 0
!=
&&
bnz branch_closeout

// Checking onCompletion type for optin application call
txn OnCompletion
int OptIn
==
bnz branch_error

// Checks the number of application args , if 0 then no method it is
txn NumAppArgs
int 0
==
bz branch_method_router
b branch_error

///////////////////////////////////////////
branch_delete:

	callsub sub_check_owner_auth
	int 1
	return

branch_closeout:

	callsub sub_check_owner_auth
	int 1
	return

///////////////////////////////////////////
branch_method_router:

	method "create_staking(application,uint64,uint64,address,address,string,string)address"
	txn ApplicationArgs 0
	==
	txn ApplicationID
	int 0
	==
	&&
	bnz method_create_staking

	method "update_staking(application,uint64,uint64,address,address,string,string)address"
	txn ApplicationArgs 0
	==
	bnz method_update_staking

	method "config_staking(pay,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),string,string,string,string,string,address,address,address,string,string,uint64,uint64)uint64"
	txn ApplicationArgs 0
	==
	bnz method_config_staking

	method "update_manager_address(pay,byte[],byte[])string"
	txn ApplicationArgs 0
	==
	bnz method_update_manager_address

	method "activate_staking()uint64"
	txn ApplicationArgs 0
	==
	bnz method_activate_staking

	// method "staking_participate(pay,axfer,pay,axfer)uint64"
	// txn ApplicationArgs 0
	// ==
	// bnz method_staking_participate

    // method "staking_withdraw_participate()uint64"
	// txn ApplicationArgs 0
	// ==
	// bnz method_staking_withdraw_participate

	method "staking_stake(uint64)uint64"
	txn ApplicationArgs 0
	==
	bnz method_staking_stake

	method "staking_unstake(uint64)uint64"
	txn ApplicationArgs 0
	==
	bnz method_staking_unstake

	b branch_error

///////////////////////////////////////////
// Subroutine to handle transaction checks
sub_check_txn:

	// Checks RekeyTo address transaction field to be empty (ZeroAddress)
	txn RekeyTo
	global ZeroAddress
	==
	assert

	// Checks CloseRemainderTo address transaction field to be empty (ZeroAddress)
	txn CloseRemainderTo
	global ZeroAddress
	==
	assert

	// Checks AssetCloseTo address transaction field to be empty (ZeroAddress)
	txn AssetCloseTo
	global ZeroAddress
	==
	assert

	// Check transaction type to be application call
	txn TypeEnum
	int appl
	==
	bz branch_error

	// Checking transaction fee
	txn Fee
	global MinTxnFee
	>=
	assert
	retsub

// Checks owner address authentication
sub_check_owner_auth:

	txn Sender
	global CreatorAddress
	==
	assert
	retsub

// Checks manager address authentication
sub_check_manager_auth:
	txn Sender
	byte "manager_address"
	app_global_get
	==
	assert
	retsub

// Handles creation of Staking contract
method_create_staking:

	global CurrentApplicationID
	store 0

	txn ApplicationArgs 1
	btoi
	store 1
	byte "dao_app_id"
	load 1
	app_global_put


	txn ApplicationArgs 2
	btoi
	store 2
	byte "dao_asset_id"
	load 2
	app_global_put

	txn ApplicationArgs 3
	btoi
	store 3
	byte "staking_asset_id"
	load 3
	app_global_put

	txn ApplicationArgs 4
	store 4
	byte "manager_address"
	load 4
	app_global_put

	txn ApplicationArgs 5
	store 5
	byte "dao_manager_address"
	load 5
	app_global_put

	txn ApplicationArgs 6
	store 6
	byte "staking_name"
	load 6
	app_global_put

	txn ApplicationArgs 7
	store 7
	byte "staking_description"
	load 7
	app_global_put


	


	byte "stakings_count"
	int 0
	app_global_put

	byte "staking_is_activated"
	int 0
	app_global_put

	byte "staked_amount_algo"
	int 0
	app_global_put

	byte "staked_amount"
	int 0
	app_global_put



	byte 0x151f7c75
	global CurrentApplicationAddress
	concat
	b branch_log_return

// Handles updating of Staking contract
method_update_staking:
	//byte "staking_is_activated"
	//app_global_get
	//int 1
	//!=
	//assert

	global CurrentApplicationID
	store 0

	txn ApplicationArgs 1
	btoi
	store 1
	byte "dao_app_id"
	load 1
	app_global_put

	txn ApplicationArgs 2
	btoi
	store 2
	byte "dao_asset_id"
	load 2
	app_global_put

	txn ApplicationArgs 3
	btoi
	store 3
	byte "staking_asset_id"
	load 3
	app_global_put

	txn ApplicationArgs 4
	store 4
	byte "manager_address"
	load 4
	app_global_put

	txn ApplicationArgs 5
	store 5
	byte "dao_manager_address"
	load 5
	app_global_put

	txn ApplicationArgs 6
	store 6
	byte "staking_name"
	load 6
	app_global_put

	txn ApplicationArgs 7
	store 7
	byte "staking_description"
	load 7
	app_global_put

	byte 0x151f7c75
	global CurrentApplicationAddress
	concat
	b branch_log_return

// Handles updating of a staking contract manager address
method_update_manager_address:
	callsub sub_check_manager_auth

	txn ApplicationArgs 1
	byte "manager_address"
	app_global_put

	byte 0x151f7c75
	byte "Staking manager address is now updated!"
	concat
	b branch_log_return

// Handles activation of Staking
method_activate_staking:
	callsub sub_check_manager_auth
	

	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return

// Handles configuration of Staking
method_config_staking:
	byte "participation_count"
	app_global_del
	
	gtxn 0 TypeEnum
	int pay
	==
	bz branch_error

	gtxn 0 Amount
	int 3000
	>=
	assert

	gtxn 0 Receiver
	global CurrentApplicationAddress
	==
	assert

	txn ApplicationArgs 1 
	store 0

	load 0
	int 0
	extract_uint64 //staking_min_participation_algo
	store 1
	byte "staking_min_participation_algo"
	load 1
	app_global_put
	//log

	load 0
	int 8
	extract_uint64 //staking_min_participation_token
	store 2
	byte "staking_min_participation_token"
	load 2
	app_global_put
	//log

	load 0
	int 16
	extract_uint64 //staking_duration
	store 3
	byte "staking_duration"
	load 3
	app_global_put
	//log

	load 0
	int 24
	extract_uint64 //staking_min_duration
	store 4
	byte "staking_min_duration"
	load 4
	app_global_put
	//log

	load 0
	int 32
	extract_uint64 //staking_commission_percentage
	store 5
	byte "staking_commission_percentage"
	load 5
	app_global_put
	//log

	load 0
	int 40
	extract_uint64 //staking_commission_percentage_algo
	store 6
	byte "staking_commission_percentage_algo"
	load 6
	app_global_put
	//log

	load 0
	int 48
	extract_uint64 //staking_participation_fee
	store 7
	byte "staking_participation_fee"
	load 7
	app_global_put
	//log

	load 0
	int 56
	extract_uint64 //staking_participation_fee_algo
	store 8
	byte "staking_participation_fee_algo"
	load 8
	app_global_put
	//log

	load 0
	int 64
	extract_uint64 //staking_incentives_percentage
	store 9
	byte "staking_incentives_percentage"
	load 9
	app_global_put
	//log

	load 0
	int 72
	extract_uint64 //staking_type
	store 10
	byte "staking_type"
	load 10
	app_global_put
	//log

	load 0
	int 80
	extract_uint64 //staking_incentives_duration
	store 11
	byte "staking_incentives_duration"
	load 11
	app_global_put
	//log

	load 0
	int 88
	extract_uint64 //staking_incentives_eligibility
	store 12
	byte "staking_incentives_eligibility"
	load 12
	app_global_put
	//log

	txn ApplicationArgs 2 //staking_name
	store 13
	byte "staking_name"
	load 13
	app_global_put
	//log

	txn ApplicationArgs 3 //staking_description
	store 13
	byte "staking_description"
	load 13
	app_global_put
	//log

	txn ApplicationArgs 4 //staking_website
	store 14
	byte "staking_website"
	load 14
	app_global_put
	//log

	txn ApplicationArgs 5 //staking_banner
	store 15
	byte "staking_banner"
	load 15
	app_global_put
	//log

	txn ApplicationArgs 6 //staking_proxy_app_id
	store 16
	byte "staking_proxy_app_id"
	load 16
	app_global_put
	//log

	txn ApplicationArgs 7 //staking_proxy_app_address
	store 17
	byte "staking_proxy_app_address"
	load 17
	app_global_put
	//log

	txn ApplicationArgs 8 //staking_proxy_app_creator
	store 18
	byte "staking_proxy_app_creator"
	load 18
	app_global_put
	//log

	txn ApplicationArgs 9 //staking_proxy_app_manager
	store 19
	byte "staking_proxy_app_manager"
	load 19
	app_global_put
	//log

	txn ApplicationArgs 10 //staking_proxy_app_created_at
	store 20
	byte "staking_proxy_app_created_at"
	load 20
	app_global_put
	//log

	txn ApplicationArgs 11 //staking_proxy_app_updated_at
	store 21
	byte "staking_proxy_app_updated_at"
	load 21
	app_global_put
	//log

	txn ApplicationArgs 12 //staking_proxy_app_is_whitelisted
	store 22
	byte "staking_proxy_app_is_whitelisted"
	load 22
	btoi
	app_global_put
	//log

	txn ApplicationArgs 13 //staking_proxy_app_is_pending
	store 23
	byte "staking_proxy_app_is_pending"
	load 23
	btoi
	app_global_put
	//log

	itxn_begin
	global CurrentApplicationAddress
	itxn_field Sender
	int axfer
	itxn_field TypeEnum
	global CurrentApplicationAddress
	itxn_field AssetReceiver
	int 0
	itxn_field AssetAmount
	txna Assets 1
	itxn_field XferAsset
	itxn_submit
	itxn TxID
    log

	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return

branch_stake_new_account:
	load 9
	gtxn 1 Amount
	itob
	box_put

	load 11
	gtxn 2 AssetAmount
	itob
	box_put

	b branch_stake_continue


method_staking_stake:
	txna Accounts 0 // DAO main account
	store 0 // DAO main account
	txn Sender // Staking user account
	store 1 // Staking user account

	txn ApplicationArgs 1 // The staked amount algo
	btoi
	store 3 // The staked amount algo

	
	txn ApplicationArgs 2 // The staked amount token
	btoi
	store 4 // The staked amount token


	// Checking the staking activation
	byte "staking_is_activated"
	app_global_get
	bz branch_error_activation

	// Checking Transaction group
    global GroupSize
    int 4
    ==
    assert

    // Checking the pay and axfer txns
	gtxn 1 RekeyTo
    global ZeroAddress
    ==
    gtxn 2 RekeyTo
    global ZeroAddress
    ==
	&&
	assert
	gtxn 1 Fee
    global MinTxnFee
    >=
    gtxn 2 Fee
    global MinTxnFee
    >=
	&&
	assert

	gtxn 1 CloseRemainderTo
	global ZeroAddress
	==
	gtxn 2 CloseRemainderTo
	global ZeroAddress
	==
	&&
	assert

	// Checking the asset ref to be Staking asset ID
    byte "staking_asset_id"
    app_global_get
    gtxn 2 XferAsset
    ==
    assert

	// Checking staking minimum participation algos
	gtxn 1 Amount
	store 5 // The staked amount algo
	load 5
    byte "staking_min_participation_algo"
	app_global_get
    >=
    assert
	load 5
	load 3
	==
	assert

	// Checking staking minimum participation tokens
    gtxn 2 AssetAmount
	store 6 // The staked amount token
	load 6
    byte "staking_min_participation_token"
	app_global_get
    >=
    assert
	load 6
	load 4
	==
	assert

	// Check participation and box preparation
	load 1
	byte "_algo"
	concat
	store 9 // the stake account algo box name

	load 1
	byte "_token"
	concat
	store 11 // the stake account token box name

	int 0
	dup
	store 10
	store 12

// Checking staked algo amount box 
	load 9
	box_get
	bz branch_stake_continue
	btoi
	store 10 // Staked amounts algos from account box
	load 9
	box_del
	assert

	load 11
	box_get
	bz branch_stake_continue
	btoi
	store 12 // Staked amounts tokens from account box
	load 11
	box_del
	assert


branch_stake_continue:
	// Staking finalization and account boxes staking values update
	load 9
	load 10
	load 5
	+
	itob
	box_put

	load 11
	load 12
	load 6
	+
	itob
	box_put
	
	// Stats update
	byte "stakings_count"
	dup
	app_global_get
	int 1
	+
	app_global_put

	byte "staked_amount_algo"
	app_global_get
	load 5
	+ // The total staked amount algo
	byte "staked_amount_algo"
	swap
	app_global_put

	byte "staked_amount"
	app_global_get
	load 4
	+// The total staked amount token
	byte "staked_amount"
	swap
	app_global_put


	// Log and return
	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return

method_staking_unstake:
	// Checking the staking activation
	byte "staking_is_activated"
	app_global_get
	bz branch_error_activation

	   // Checking the asset ref to be staking asset
    byte "staking_asset_id"
    app_global_get
    txna Assets 0
    ==
    assert

	// Checking Transaction group
    global GroupSize
    int 2
    ==
    assert

	txna Accounts 0
	store 0 // DAO main account
	txn Sender
	store 1

	// The unstaked amount algo
	txn ApplicationArgs 1
	btoi
	store 2

	// The unstaked amount token
	txn ApplicationArgs 2
	btoi
	store 3

 

	// Check participation and box preparation
	load 1
	byte "_algo"
	concat
	store 4 // the stake account algo box name
	load 4
	box_get
	assert
	btoi
	store 5 // Staked amounts algos from account box
	load 4
	box_del
	assert

	load 1
	byte "_token"
	concat
	store 6 // the stake account token box name
	load 6
	box_get
	assert
	btoi
	store 7 // Staked amounts tokens from account box
	load 6
	box_del
	assert

	

	// Staking finalization
	load 4
	load 5
	load 2
	-
	store 8
	load 8
	itob
	box_put

	load 6
	load 7
	load 3
	-
	store 9
	load 9
	itob
	box_put
	
	// Staking refund transactions
	itxn_begin
	global CurrentApplicationAddress
	itxn_field Sender
	load 0
	itxn_field Receiver
	load 8
	itxn_field Amount
	int pay
	itxn_field TypeEnum
	itxn_submit

	itxn_begin
	global CurrentApplicationAddress
	itxn_field AssetSender
	load 0
	itxn_field AssetReceiver
	load 9
	itxn_field AssetAmount
	int axfer
	itxn_field TypeEnum
	itxn_submit

	// Stats update
	

	// Log and return
	byte 0x151f7c75
	global CurrentApplicationID
	itob
	concat
	b branch_log_return


// Handles logging the last element on the stack then put a 1 on the top and return (log and approve)
branch_log_return:
	log
	int 1
	return

branch_error:
	err
branch_error_activation:
	err

